<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prepositional Phrase Hunt</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Luckiest+Guy&display=swap');
        
        :root {
            --primary-color: #4A90E2;
            --secondary-color: #FFC107;
            --accent-color: #FF7043;
            --text-color: #fff;
            --bg-dark: #2c3e50;
            --bg-light: #ecf0f1;
        }

        body {
            font-family: 'Luckiest Guy', cursive;
            background-color: #000;
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .game-container {
            text-align: center;
            background: rgba(0, 0, 0, 0.2);
            padding: 2rem;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 800px;
            border: 4px solid var(--accent-color);
            position: relative;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            color: var(--secondary-color);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.5rem;
            margin-bottom: 1rem;
            padding: 0 1rem;
        }
        
        #game-canvas {
            background-color: var(--bg-light);
            border: 4px dashed var(--primary-color);
            border-radius: 10px;
            cursor: crosshair;
            touch-action: none;
            width: 100%;
            height: 400px;
            margin-bottom: 1.5rem;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.3);
        }

        #assembled-phrase {
            font-size: 2rem;
            min-height: 2.5rem;
            border-bottom: 3px solid var(--text-color);
            margin: 0 auto 1.5rem;
            padding-bottom: 0.5rem;
            color: var(--text-color);
            text-transform: uppercase;
            font-weight: bold;
        }

        #start-button, #replay-button {
            padding: 1rem 2rem;
            font-size: 1.5rem;
            font-family: 'Luckiest Guy', cursive;
            background-color: var(--accent-color);
            color: var(--text-color);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        #start-button:hover, #replay-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
        }
        
        #start-button:active, #replay-button:active {
            transform: translateY(0);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .hidden {
            display: none;
        }

        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 20px;
            text-align: center;
        }
        
        #game-over-screen.hidden {
            display: none;
        }

        #final-score {
            font-size: 3rem;
            color: var(--secondary-color);
            margin: 1rem 0;
        }

        .word-on-canvas {
            color: var(--bg-dark);
            font-size: 24px;
            font-weight: bold;
            padding: 8px 12px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: background-color 0.1s ease;
        }

        @media (max-width: 600px) {
            .game-container {
                width: 95%;
                padding: 1rem;
            }
            h1 {
                font-size: 1.8rem;
            }
            #game-info {
                font-size: 1.2rem;
            }
            #assembled-phrase {
                font-size: 1.5rem;
            }
            #start-button, #replay-button {
                font-size: 1.2rem;
                padding: 0.8rem 1.5rem;
            }
            #final-score {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>

<div class="game-container">
    <h1>Prepositional Phrase Hunt</h1>

    <div id="game-info">
        <span id="score-display">Score: 0</span>
        <span id="timer-display">Time: 3:00</span>
    </div>

    <canvas id="game-canvas"></canvas>

    <div id="assembled-phrase"></div>

    <button id="start-button">Start Game</button>

    <div id="game-over-screen" class="hidden">
        <h2 style="font-size: 2.5rem; color: var(--accent-color);">Game Over!</h2>
        <div id="final-score"></div>
        <button id="replay-button">Play Again?</button>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // Get references to HTML elements
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const timerDisplay = document.getElementById('timer-display');
        const assembledPhraseDisplay = document.getElementById('assembled-phrase');
        const startButton = document.getElementById('start-button');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreDisplay = document.getElementById('final-score');
        const replayButton = document.getElementById('replay-button');

        // Game configuration and state variables
        const gameDuration = 180; // 3 minutes in seconds
        let gameRunning = false;
        let score = 0;
        let timeLeft = gameDuration;
        let lastTime = 0; // Initialize with 0 to signal the first frame
        let words = [];
        let assembledPhrase = [];
        let currentPhrase = [];
        let gameLoopId;

        // List of prepositional phrases for the game
        const prepositionalPhrases = [
            "in the box",
            "on the table",
            "under the bridge",
            "with a friend",
            "across the street",
            "for the king",
            "by the river",
            "without a care",
            "through the woods",
            "at the house",
            "of the people",
            "from the school",
            "to the moon",
            "against the wall",
            "inside the car",
            "outside the fence",
            "above the clouds",
            "below the water",
            "beside the fire",
            "behind the curtain",
            "between the lines",
            "down the stairs",
            "into the forest",
            "onto the stage",
            "off the list",
            "since last year",
            "until tomorrow",
            "up the ladder",
            "within the hour"
        ];
        
        // A list of distractor words to make the game more challenging
        const distractorWords = [
            "JUMPING", "RUNNING", "FAST", "SLOW", "BIG", "SMALL",
            "BLUE", "RED", "GREEN", "HAPPY", "SAD", "EATING",
            "SLEEPING", "DRINKING", "TALKING", "QUIET", "LOUD",
            "SUNNY", "RAINY", "WINDY"
        ];

        // Word object class to manage bouncing words
        class Word {
            constructor(text, x, y, dx, dy, textColor, boxColor) {
                this.text = text;
                this.x = x;
                this.y = y;
                this.dx = dx; // velocity on x-axis
                this.dy = dy; // velocity on y-axis
                this.textColor = textColor;
                this.boxColor = boxColor;
                this.width = 0;
                this.height = 0;
                this.isCollected = false;
            }

            // Method to draw the word on the canvas
            draw() {
                if (this.isCollected) return; // Don't draw collected words
                
                // Get word dimensions for collision detection
                ctx.font = "24px 'Luckiest Guy', cursive";
                const metrics = ctx.measureText(this.text);
                this.width = metrics.width + 24; // text width + padding
                this.height = 40; // a fixed height for simplicity
                
                ctx.save();
                ctx.translate(this.x, this.y);

                // Draw rounded rectangle background
                ctx.fillStyle = this.boxColor;
                ctx.beginPath();
                ctx.roundRect(-this.width / 2, -this.height / 2, this.width, this.height, 8);
                ctx.fill();

                // Draw word text
                ctx.fillStyle = this.textColor;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.text, 0, 0);

                ctx.restore();
            }

            // Method to update the word's position and handle bouncing
            update() {
                if (this.isCollected) return;
                
                // Reverse direction if hitting horizontal walls
                if (this.x + this.dx > canvas.width - this.width / 2 || this.x + this.dx < this.width / 2) {
                    this.dx = -this.dx;
                }
                // Reverse direction if hitting vertical walls
                if (this.y + this.dy > canvas.height - this.height / 2 || this.y + this.dy < this.height / 2) {
                    this.dy = -this.dy;
                }
                
                // Update position
                this.x += this.dx;
                this.y += this.dy;
            }
        }

        // --- Game Logic Functions ---

        // Function to set up the game for a new phrase
        function initializePhrase() {
            const randomPhrase = prepositionalPhrases[Math.floor(Math.random() * prepositionalPhrases.length)];
            currentPhrase = randomPhrase.split(" ");
            
            words = [];
            assembledPhrase = [];
            assembledPhraseDisplay.textContent = "";
            const boxColor = '#1e3a8a'; // Dark Blue box color
            const textColor = '#FFC107'; // Yellow text color

            // Add the correct words to the game
            currentPhrase.forEach(wordText => {
                const x = Math.random() * (canvas.width - 100) + 50;
                const y = Math.random() * (canvas.height - 100) + 50;
                const dx = (Math.random() - 0.5) * 3;
                const dy = (Math.random() - 0.5) * 3;
                words.push(new Word(wordText.toUpperCase(), x, y, dx, dy, textColor, boxColor));
            });

            // Add distractor words to make the game more difficult
            const numDistractors = Math.floor(Math.random() * (10 - 5 + 1)) + 5; // Generate between 5 and 10 distractors
            for (let i = 0; i < numDistractors; i++) {
                const randomDistractor = distractorWords[Math.floor(Math.random() * distractorWords.length)];
                const x = Math.random() * (canvas.width - 100) + 50;
                const y = Math.random() * (canvas.height - 100) + 50;
                const dx = (Math.random() - 0.5) * 3;
                const dy = (Math.random() - 0.5) * 3;
                words.push(new Word(randomDistractor.toUpperCase(), x, y, dx, dy, textColor, boxColor));
            }
        }

        // The main game loop
        function gameLoop(currentTime) {
            // If it's the first frame, initialize lastTime to the current time to prevent a time jump
            if (lastTime === 0) {
                lastTime = currentTime;
            }
            
            // Only run the loop if the game is active
            if (!gameRunning) {
                cancelAnimationFrame(gameLoopId);
                return;
            }

            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Update timer
            timeLeft -= deltaTime / 1000;
            if (timeLeft <= 0) {
                timeLeft = 0;
                endGame();
            }
            updateTimerDisplay();

            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update and draw all words
            words.forEach(word => {
                word.update();
                word.draw();
            });

            // Request the next frame
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // Function to start the game
        function startGame() {
            gameRunning = true;
            score = 0;
            timeLeft = gameDuration;
            lastTime = 0;

            startButton.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            
            updateScoreDisplay();
            updateTimerDisplay();
            
            initializePhrase();
            
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // Function to end the game
        function endGame() {
            gameRunning = false;
            finalScoreDisplay.textContent = `Final Score: ${score}`;
            gameOverScreen.classList.remove('hidden');
        }

        // Function to update the score display
        function updateScoreDisplay() {
            scoreDisplay.textContent = `Score: ${score}`;
        }

        // Function to update the timer display
        function updateTimerDisplay() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = Math.floor(timeLeft % 60);
            timerDisplay.textContent = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // --- Event Listeners ---
        
        // Handle clicks on the canvas
        canvas.addEventListener('mousedown', (event) => {
            if (!gameRunning) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseX = (event.clientX - rect.left) * scaleX;
            const mouseY = (event.clientY - rect.top) * scaleY;
            
            let found = false;
            let clickedWord = null;

            for (const word of words) {
                if (mouseX >= word.x - word.width / 2 && mouseX <= word.x + word.width / 2 &&
                    mouseY >= word.y - word.height / 2 && mouseY <= word.y + word.height / 2) {
                    
                    clickedWord = word;
                    found = true;
                    break;
                }
            }
            
            if (found) {
                const nextCorrectWord = currentPhrase[assembledPhrase.length].toUpperCase();

                if (clickedWord.text === nextCorrectWord.toUpperCase()) {
                    assembledPhrase.push(clickedWord.text);
                    assembledPhraseDisplay.textContent = assembledPhrase.join(" ");
                    
                    clickedWord.isCollected = true;
                    
                    if (assembledPhrase.length === currentPhrase.length) {
                        score++;
                        updateScoreDisplay();
                        setTimeout(initializePhrase, 1000);
                    }
                }
            }
        });

        canvas.addEventListener('touchstart', (event) => {
            event.preventDefault();
            const touch = event.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        }, false);

        startButton.addEventListener('click', startGame);
        replayButton.addEventListener('click', startGame);

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = 400;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    });
</script>
</body>
</html>
